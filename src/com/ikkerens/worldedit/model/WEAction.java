package com.ikkerens.worldedit.model;

import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.HashSet;

import com.ikkerens.worldedit.exceptions.BlockLimitException;
import com.ikkerens.worldedit.model.pattern.SetBlockType;

import com.mbserver.api.game.Chunk;
import com.mbserver.api.game.World;

public class WEAction {
    private final World                                  world;
    private final boolean                                recordAction;
    private final int                                    limit;
    private int                                          affected;

    private final HashSet< Chunk >                       chunks;
    private ArrayList< SimpleEntry< Integer[], Short > > undoList;

    WEAction( final World world, final boolean recordAction, final int limit ) {
        this.world = world;
        this.recordAction = recordAction;
        this.limit = limit;

        if ( this.recordAction )
            this.undoList = new ArrayList< SimpleEntry< Integer[], Short > >();

        this.chunks = new HashSet< Chunk >();
    }

    public void setBlock( final int x, final int y, final int z, final short blockID ) throws BlockLimitException {
        final short current = this.world.getFlaggedBlockID( x, y, z );

        if ( current != blockID ) {
            if ( ( this.limit != -1 ) && ( this.affected >= this.limit ) )
                throw new BlockLimitException();

            if ( this.recordAction )
                this.undoList.add( new SimpleEntry< Integer[], Short >( new Integer[] { x, y, z }, current ) );

            this.world.setBlockWithoutUpdate( x, y, z, blockID );

            this.chunks.add( this.world.getChunk( x, y, z, true ) );

            this.affected++;
        }
    }

    public void setBlock( final int x, final int y, final int z, final SetBlockType type ) throws BlockLimitException {
        this.setBlock( x, y, z, type.getNextBlock( x, y, z ) );
    }

    public void destroy( final int x, final int y, final int z, final short tool ) throws BlockLimitException {
        if ( ( this.limit != -1 ) && ( this.affected >= this.limit ) )
            throw new BlockLimitException();

        if ( this.recordAction )
            this.undoList.add( new SimpleEntry< Integer[], Short >( new Integer[] { x, y, z }, this.world.getFlaggedBlockID( x, y, z ) ) );

        if ( tool == 0 )
            this.world.destroyNaturally( x, y, z );
        else
            this.world.destroyWithTool( tool, x, y, z );

        this.affected++;
    }

    public void undo() {
        for ( final SimpleEntry< Integer[], Short > entry : this.undoList ) {
            final Integer[] keys = entry.getKey();
            this.world.setBlockWithoutUpdate( keys[ 0 ], keys[ 1 ], keys[ 2 ], entry.getValue() );
            this.chunks.add( this.world.getChunk( keys[ 0 ], keys[ 1 ], keys[ 2 ], true ) );
        }
        this.finish();
    }

    public void finish() {
        for ( final Chunk ch : this.chunks )
            if ( ch != null )
                ch.recalculateLight();
        this.chunks.clear();
    }

    public int getAffected() {
        return this.affected;
    }
}
